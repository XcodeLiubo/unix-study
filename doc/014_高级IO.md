### 引言
- 前面所有的IO从调用类型来看, 分为2类:系统调用IO. 也称为文件IO(<font color = green>章节标题</font>), 这种IO不带缓冲;标准IO. 它依赖于系统调用IO, 但标准库在实现时作了用户级别的缓冲(<font color = green>回顾第5章</font>); 操作系统公开的IO接口是统一的, 但实际会根据文件类型的不同, IO的效果也不同. 举例来说: 读取普通文件时(`目录或文本文件`)会立即返回; 读取设备时如标准输入会因为没有数据而阻塞进程. 本章就是更加细分阻塞IO的读取操作. 怎么解决阻塞IO会涉及到更多的技术: 非阻塞IO, 记录锁, IO多路转接, 异步IO, 存储映射IO等. 后面章节还会介绍到网络间的数据IO操作


### 非阻塞IO
- 回顾第10章系统调用分为2类: 低速系统调用和其他. 低速系统调用可能会<font color = deeppink>永久阻塞</font>当前进程, 这一类的系统调用, 包括:
    - 若读取文件数据不存在时, 读操作可能会阻塞调用者. 一般是管道,终端设备,网络设备
    - 若写入文件时, 数据不能被立即接受, 则可能阻塞当前进程. 如管道中没有空间, 网络设备等)
    - 打开某些类型的文件时可能阻塞当前进程. 如打开一个终端设备, 等待接连的调制解调器应答. 又如以写模式打开管道时, 在没有其他进程以读模式打开时也要等待
    - 对已经上写锁的文件进读写时, 也会阻塞当前进程
    - 某些ioctl操作
    - 某些进程间通信
    
> PS: 当进行磁盘读写操作时, 可能会暂时阻塞调用者, 但不能视为低速, 当不可写时, 会立即返回到调用者. 

- 所谓的非阻塞IO表示发起读写操作时不发生永久阻塞的情况, 即使这些对象是设备,管道等. 若不能立即进行则出错返回到用户. 所有的文件都可以在调用<font color = deeppink>open</font>函数时可以指定非阻塞IO的选项(`O_NONBLOCK`). 对于已经打开的文件, 可以通过`fcntl`函数改为非阻塞模式


- `O_NONBLOCK`选项是文件状态标志. 回顾第3章该标志属于文件表荐, 它和文件描述符表是分开的. 其`fork`和`dup, dup2`函数会使其共享文件表项. 下面的2个demo是测试非阻塞的2种不同的版本
    1. 标准IO
    2. 文件IO

<br/>

```cpp
#include<unistd.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<iostream>
#include<cstdio>

using namespace std;

char buf[64];

int main(int arg, char** argv){
    chdir("/Users/liubo/Desktop/work/study/code");
    // 这里要打开管道, 加上标准IO在调用fopen不能指定文件选项
    // 所以这里发现没有写者时是阻塞的
    file = fopen("./test.pipe", "r");

    if(file == nullptr){
        perror("fopen");
        exit(-1);
    }


    // 代码来这里, 说明已经从管道中读取到了内容
    cout << "open suc\n";

_read:
    if(fgets(buf, sizeof(buf), file)){
        if(ferror(file)){
            // 阻塞模式下要判断 EINTR
            if(errno == EAGAIN || errno == EINTR)
                goto _read;
            exit(-1);
        }

        if(feof(file)){
            // 结束后, 立即往下执行测试非阻塞模式
        }
    }

    cout << "read suc:" << buf << endl;
    clearerr(file);


    // 获取当前的文件状态标志
    auto file_fd = fileno(file);
    auto o_file_status = fcntl(file_fd, F_GETFL);
    // 判断当前文件状态标志是不是非阻塞的, 若是则直接阻塞
    if(o_file_status & O_NONBLOCK){
        fcntl(file_fd, F_SETFL, o_file_status & (~O_NONBLOCK));
    }else{
        fcntl(file_fd, F_SETFL, o_file_status | O_NONBLOCK);
    }

    while(1){
        // 没有数据时, if返回为空, 会在这里不断循环读取管道
        if(ferror(file)){
            if(errno == EAGAIN){
                cerr << "over\n";
                clearerr(file);
                continue;
            }
            exit(-1);
        }
        if(feof(file)){
            cerr << "eof\n";
            clearerr(file);
            continue;
        }
        if(fgets(reinterpret_cast<char*>(buf), sizeof(buf), file)){
            cout << "read suc:" << buf << endl;
            clearerr(file);
        }
    }
    fclose(file);
    return 0;
}
```

<br/>

> 上述使用的是标准IO, 这里要注意:标准IO在发起`fgets`后, 会一次性读取一大块文件数据到缓冲内存中, 然后再一个一个从存在中读取. 这里在出现`EINTR`时是一种假错(`回顾第10章`), 有的系统调用会自动重启(`也是第10章`), 当调用发生阻塞时, 可能会被其他信号中断, 但不应该视为出错. 非阻塞模式时, 不要管这个信号 


<br/>

```cpp
#include<unistd.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<iostream>
#include<cstdio>

using namespace std;

int8_t buf[64];

int main(int arg, char** argv){
    chdir("/Users/liubo/Desktop/work/study/code");
    // 以只读打开, 因为内部调用系统调用, 所以默认是阻塞的
    auto fd   = open("./test.pipe", O_RDONLY);
    if(fd < 0){
        perror("open");
        exit(-1);
    }
    cerr << "open suc" << endl;

_read:
    auto res = read(fd, buf, sizeof(buf));
    if(res < 0){
        if(errno == EAGAIN || errno == EINTR)
            goto _read;
        exit(-1);
    }

    // 这里表示读取结束, 对于系统IO来说,不用管, 立即进入下面的非阻塞模式的测试
    //if(res == 0){ goto _read;}



    cout << "read suc:" << buf << endl;
    memset(buf, 0, sizeof(buf));

    auto o_file_status = fcntl(fd, F_GETFL);
    // 判断当前文件状态标志是不是非阻塞的, 若是则直接阻塞
    if(o_file_status & O_NONBLOCK){
        cout << "原来是非阻塞的\n";
        fcntl(fd, F_SETFL, o_file_status & (~O_NONBLOCK));
    }else{
        cout << "原来是阻塞的\n";
        fcntl(fd, F_SETFL, o_file_status | O_NONBLOCK);
    }

    while(1){
        res = read(fd, buf, sizeof(buf));
        if(res < 0){
            if(errno == EAGAIN){
                continue;
            }
            exit(-1);
        }
        if(res == 0){
            continue;
            break;
        }
        cout << "read suc:" << buf << endl;
        memset(buf, 0, sizeof(buf));
    }

    close(fd);
    return 0;
}
```

<br/>

> 上述是系统IO, 编写和标准IO一样. 但它们的运行机制不一样, 系统IO每次只读要求长度的数据. 这里要再说明一下: 系统IO在读取操作时内部有自己的优化机制, 它也会向磁盘索取一大块数据放入到内存中. 原理和标准IO一样. 但2者在速度上有很大不同, 标准IO要快的多. 因为系统IO是将数据存放到内核缓冲区, 每次系统IO的操作, 会发生一次内核缓冲区到用户缓冲区的复制. 而标准IO一般读取的长度会比要求的多, 它调用系统IO一次性索取更大的数据, 直接从内核缓冲区复制到用户缓冲区后, 再在用户缓冲区处理. 向内核调用的次数越少, 用户态及内核态2者之间的转换就越少, 复制操作就越少, 速度就越快. 其实这种速度的差异主要体现在数据量少的情况.
>
> 实际上标准IO不能在打开文件时就指定非阻塞模式, 本例能测试成功是因为启动后就要测试阻塞模式. 如果要求使用标准IO来处理, 则流程上应该先创建文件描述符, 即调用系统IO在打开时就指定非阻塞模式, 再将文件描述符转换成FILE
>
> 以上程序不适合用c++的文件流处理: 
>   1. 这里要求非阻塞IO, 但在c++的流对象中无法获取到FILE对象, 所以无法找到文件描述符来进行设置(`某些非标准可以`).
>   2. 文件流在构造时就直接读取文件, 由于打开文件时默认是阻塞式的, 以本例中的管道来说构造时就阻塞了
>   3. 文件流读取管道时, 无法判断当前文件是否结束. 
>   4. 若文件写者关闭, 则文件流读取时出错, 其实和第3条一样
>

<br/>


### clang,g++获取文件描述符

- 笔者当前的clang版本为`15.0.0`, 架构为`M2(Arm64)`. 这个版本的标准库有2种方式可以得到FILE对象: 第1种是验证源码所整理出来的结构, 在代码中经过类型的强制转换可以取到FILE对象; 第2种也是观察了结构, 但是通过继承重写方式, 这种方法可以先创建文件描述符.

```cpp

#if defined(__APPLE__) && __clang_major__ == 15 && __clang_minor__ == 0 && __clang_patchlevel == 0

// 第1种方法 
struct my_buf{
    void* ptr;
    void* _1;
    void* __binp_;
    void* __ninp_;
    void* __einp_;
    void* __bout_;
    void* __nout_;
    void* __eout_;

    char* __extbuf_;
    const char* __extbufnext_;
    const char* __extbufend_;
    char __extbuf_min_[8];
    size_t __ebs_;
    void* __intbuf_;
    size_t __ibs_;
    FILE* __file_;      // 整理到FILE就可以了, 后面的不用管

    //...
};

int main(int arg, char** argv){
    ifstream inf("./test.pipe", std::ios::ios_base::in);

    // rdbuf成员函数是标准公开可调用的, 获取到的ptr类型是文件流中的缓冲对象指针
    // 该对象是私有的, 但整理出来的结构可简化成上述的 my_buf
    auto ptr = inf.rdbuf();
    my_buf* tmp_ptr = reinterpret_cast<my_buf*>(ptr);
    FILE* file = tmp_ptr->__file_;

    // 获取当前的文件状态标志
    auto file_fd = fileno(file);
    auto o_file_status = fcntl(file_fd, F_GETFL);
    // 判断当前文件状态标志是不是非阻塞的, 若是则直接阻塞
    if(o_file_status & O_NONBLOCK){
        fcntl(file_fd, F_SETFL, o_file_status & (~O_NONBLOCK));
    }else{
        fcntl(file_fd, F_SETFL, o_file_status | O_NONBLOCK);
    }
    return 0;
}









// 第2种方法
#include<unistd.h>
#include<sys/types.h>
#include<fcntl.h>
#include<iostream>
#include<fstream>
#include<string>
#include<cerrno>
#include<cstdio>

using namespace std;

// 对于 ofstream和 fstream也是同样的道理
class MyIFile : public ifstream{
public:
    // 添加一个public对外的方法, 然后内部调用 set_rdbuf, 这个方法是protected, 所以才建了一个子类
    void set_mybuf(basic_filebuf<char_type, traits_type>* b){
        this->set_rdbuf(b);
    }
};

int main(){
    auto fd = open("./a.pipe",  O_RDONLY | O_NONBLOCK);
    if(fd < 0){
        perror("open");
        exit(-1);
    }

    // basic_filebuf这个类以及 basic_filebuf.__open方法 是公开的
    // 该方法可以以文件描述符打开
    basic_filebuf<MyIFile::char_type, MyIFile::traits_type> b;
    b.__open(fd, ios_base::in);



    // 用自定义的文件类
    MyIFile m;
    m.set_mybuf(&b);        // 内部会调用到父类


    // 测试程序
    string s;
    m >> s;
    cout << s;

    return 0;
}
#endif
```

<br/>

- 对应的在g++环境`9.4.0, Arm64`版本

```cpp
#if defined(__GNUC__) && __GNUC__ == 9 && __GNUC_MINOR__ == 4 &&  __GNUC_PATCHLEVEL__ == 0
template<typename char_type, typename T>
class my_filebuf{
public:
      void*             vptr;
      void* 		_M_in_beg;     ///< Start of get area.
      void* 		_M_in_cur;     ///< Current read area.
      void* 		_M_in_end;     ///< End of get area.
      void* 		_M_out_beg;    ///< Start of put area.
      void* 		_M_out_cur;    ///< Current put area.
      void* 		_M_out_end;    ///< End of put area.
      std::locale       _locale;
      __gthread_mutex_t _1;		//
      FILE*		file;		//
};

int main(int args, char** argv){
	using namespace std;
	using MyBuf =  my_filebuf<ifstream::char_type, ifstream::traits_type>;
	ifstream f("./a.txt", ios_base::in);
	MyBuf* buf = (MyBuf*)(f.rdbuf());
	auto fd = fileno(buf->file);
	return 0;
}
#endif
```

<br/>

> g++这种只能获取到FILE, 换言之只能是通过流打开文件后, 才能获取到, 不能在打开文件前通过fd产生流. 开发中不要使用c++的流来处理非阻塞的IO

<br/>




### 轮询
- 非阻塞IO看起来好像对开发没什么用, 它读取低速设备时, 在失败后可以尝试再进行读取(`如果业务要求必须读取到数据`), 这样会因为读不到数据一直占据CPU, 导致资源浪费, 还不如阻塞等待数据返回. 但若需求是同时读取多个低速设备, 那以现在的知识来实现, 必须用到非阻塞IO. 因为若用阻塞IO的话, 会导致在等待其中一个IO设备时, 不能知道其他设备有没有数据到来, 所以只能遍历时时检查每个设备是否有数据, 有的话就读. 
    > 当然可以使用多线程技术, 对于每1个低速设备者使用阻塞IO, 但现在这里不讨论这个(后面会简单实现一下)

```txt
4个管道
    a.pipe
    b.pipe
    c.pipe
    d.pipe
    
    PS: mkfifo 创建管道的命令


2个进程
    1. 读进程
    2. 写进程
    
    2个进程都只用1条线程
    打开4个管道. 
    进程1开启非阻塞模式读取, 并且时时循环检查是否有数据. 
    进程2是写模式, 它每隔1秒循环4次, 向4个管道中写入数据

    PS: 因为当前测试案例使用的是 makefifo创建的命名管道文件.
        在只写打开时指定非阻塞会因为没有读者就直接结束. 
        所以在代码中使用pipe创建一个匿名管道可以进行非阻塞写
```

<br/>

> 写入端代码

```cpp
#include<unistd.h>
#include<sys/types.h>
#include<fcntl.h>
#include<iostream>
#include<thread>
#include<cerrno>
#include<cstdio>
#include<cstdlib>
#include<algorithm>

using namespace std;

static constexpr const char* PATH[] = {
    "./a.pipe",
    "./b.pipe",
    "./c.pipe",
    "./d.pipe",
};

static constexpr auto LEN = 4;

static FILE* FILES[LEN] = {nullptr};

static constexpr auto BUF_SIZE = 64;
static int8_t BUF[LEN][BUF_SIZE] = {0};

int main(int args, char** argv){
    chdir("/Users/liubo/Desktop/work/study/code");

    // 因为是写入, 直接通过 fopen打开文件
    for(int i = -1, j = LEN; ++i < j;){
        FILES[i] = fopen(PATH[i], "w");
        if(FILES[i] == nullptr){
            perror("fdopen");
            exit(-1);
        }
    }

    // 每隔1秒向4个管道写入数据
    while(1){
        for(int i = -1; ++i < LEN;){
            snprintf(reinterpret_cast<char*>(BUF[i]), BUF_SIZE, "%d--hello\n", i);
            if(fputs(reinterpret_cast<char*>(BUF[i]), FILES[i])){
                fflush(FILES[i]);
            }

            // 这里直接通过 fputs的返回值来判断是否写入成功
            // 比较严谨的作法是调用 feof 和 ferror来检测流的状态
        }
        sleep(1);
    }


    // 等待线程结束
    for_each(begin(FILES), end(FILES), [](FILE* file){
        fclose(file);
    });   

    return 0;
}
```

<br/>

> 读取端代码

```cpp
#include<unistd.h>
#include<sys/types.h>
#include<fcntl.h>
#include<iostream>
#include<thread>
#include<cerrno>
#include<cstdio>
#include<cstdlib>
#include <algorithm>

using namespace std;

static constexpr const char* PATH[] = {
    "./a.pipe",
    "./b.pipe",
    "./c.pipe",
    "./d.pipe",
};

static constexpr auto LEN = 4;

static FILE* FILES[LEN] = {nullptr};

static constexpr auto BUF_SIZE = 64;
static int8_t BUF[LEN][BUF_SIZE] = {0};

int main(int args, char** argv){
    chdir("/Users/liubo/Desktop/work/study/code");

    // 读取端设置非阻塞, 必须通过文件描述符, 然后再映射到FILE
    for(int i = -1, j = LEN; ++i < j;){
        auto file_fd = open(PATH[i], O_NONBLOCK | O_RDONLY);
        if(file_fd < 0){
            perror("open");
            exit(-1);
        }
        FILES[i] = fdopen(file_fd, "r");
        if(FILES[i] == nullptr){
            perror("fdopen");
            exit(-1);
        }
    }

    cout << "open suc\n";

    // 这里将消耗大量的CPU资源
    while(1){
        for(int i = -1, j = LEN; ++i < j;){
            auto res = fgets(reinterpret_cast<char*>(BUF[i]), BUF_SIZE, FILES[i]);
            if(ferror(FILES[i])){
                if(errno == EAGAIN){
                    clearerr(FILES[i]);
                    continue;
                }
                perror("fgets");
                exit(-1);
            }

            if(feof(FILES[i])){
                clearerr(FILES[i]);
                continue;
            }
            if(res){
                cout << reinterpret_cast<const char*>(BUF[i]) << endl;
                clearerr(FILES[i]);
            }
        }
    }

    for_each(begin(FILES), end(FILES), [](FILE* file){
        fclose(file);
    });

    return 0;
}
```

<br/>

> 测试结果如下面的这张gif图, main表示写入进程, main2表示读取进程

---

<img src="./assets/13_04.gif" />

---

<br/>

> 上述通过循环遍历来时时查看管道非常消耗资源. 对于该程序的测试模式绝大部分出错的情况是`EAGAIN`.  在这些案例中, write的操作都是阻塞式的, 但其实它本身也可以是非阻塞式, 以管道为例, 当管道中的数据满了后, 若是非阻塞则会出现`EAGAIN`. 下面的demo可以验证这一点

<br/>

```cpp
#include<unistd.h>
#include<sys/types.h>
#include<fcntl.h>
#include<iostream>
#include<thread>
#include<cerrno>
#include<cstdio>

using namespace std;

int main(int args, char** argv){
    char buf[20] = {0};

    int fds[2] = {};

    if(pipe(fds) < 0){          // __code_creat_pipe
        perror("pipe");
        exit(-1);
    }

    // fds[0]是读  fds[1]是写

    // 同时设置读写端为非阻塞
    fcntl(*(fds+1), F_SETFL, fcntl(*(fds + 1), F_GETFL) | O_NONBLOCK);
    fcntl(*(fds), F_SETFL, fcntl(*(fds), F_GETFL) | O_NONBLOCK);

    
    int res = 0;
    auto count = 0ull;
    do{
        snprintf(buf, 20, "hello wrld\n");
        res = write(*(fds+1), buf, 20);
        if(res < 0){
            // 管道满了会出现这种情况, 应该继续写
            if(errno == EAGAIN){
                cerr <<  "管道满了, 字节数:" << count << endl;
                break;
            }
            perror("write");
            exit(-1);
        }
        // end 
        if(res == 0){
            continue;
        }
        count += (strnlen(buf, 20));
        memset(buf, 0, 20);
    }while(res);


    while(pause());
    close(*fds);
    close(*(fds + 1));
    return 0;
}
```

<br/>

> 上述程序创建了一个匿名管道(`__code_creat_pipe`). 并且同时设置读写2端为非阻塞模式. 为了测试, 并未去读取管道, 当程序运行后, 只有写入的一端, 当前管道满了后, 因为是非阻塞的, 所以产生了`EGAIN`信号, 直接结束. 测试结果如下

<br/>

```shell
./main
管道满了, 字节数:36036
^C
```



<br/>

### 逐渐引申到IO多路转接
- 思来想去笔者准备通过实际场景来从轮询过渡到IO多路转接. 这样不仅对其概念会加深理解, 也会就相关问题给出解决方案.

```txt
场景:
    模拟socket的2端通信. 

分析:
    因为现在还未学习到socket, 所以demo中将使用管道来实现. 但面临的问题是:
        1. shell创建的管道在以只写时指定非阻塞会因为没有读者而直接结束, 所以最
            开始的程序都使用的是匿名管道

        2. 标准规定管道是单向的, 不允许在一个端进行读写.
            PS: 大部分OS实现时是双向的,为了演示这里认为是单向的

        3. 通信时双方要读对方的内容, 并且还要反馈给对方内容

        4. 单方处理2条管道, 怎么实现不阻塞监听管道的内容以达到及时响应

解决
    问题1
        代码中使用匿名管道(也可以使用命名管道). 因为这种形式创建的管道可以非阻塞的读写

    问题2, 3:
        使用2条匿名管道. 
        假设
            2个进程
                A, B 
            2条管道
                P1, P2

        规定: 
            A读P1, 写P2
            B读P2, 写P1


下面的图展示了这个流程
```

<br/>

```mermaid
flowchart LR
    A ---->|a wto P2 == b rfr P2| B
    B ---->|a rfr P1 == b wto P1| A
```

<br/>

> `wto`表示`write to`. `rfr`表示`read from`

<br/>

```txt
    上图其实隐含了一个新的问题:
        以A来说, (A write to P2) 的操作必须由 (A read from P1) 的操作成功, 即读取到了数据.
        换句话说就是写的动作是由读的动作驱动的. 对于B来说也是一样的, B只有读取到了数据(B read from P2),
        才会 (B write to P1).

    解决:
        以A来说, 轮询(A read from P1)
            > 成功后(A write to P2)
            > 失败关闭退出

        以B来说, 轮询(B read from P2)
            > 成功后 B write to P1
            > 失败关闭退出
```

<br/>

```cpp
#include<unistd.h>
#include<sys/types.h>
#include<fcntl.h>
#include<iostream>
#include <thread>
#include<tuple>
#include<cerrno>
#include<cstdio>

using namespace std;


/** 指示poll时的动作*/
enum class OPER_STA {
    read,
    write,
    over,       // 正常结束
    ex          // 异常结束
};

struct pipe_descripe{
    int rfd;
    int wfd;
};
static pipe_descripe PIPES[2];

auto constexpr BUF_SIZE = 128;
static int8_t BUF[BUF_SIZE];

// 规定第0组是P1, 第1组是P2
static inline pipe_descripe* get_pipe(bool child = false){
    return child ? (PIPES + 1) : PIPES;
}

#define P1() get_pipe()
#define P2() get_pipe(true)

#define PR (P1()->rfd)      // parent == A ==> A read from P1
#define PW (P2()->wfd)      // parent == A ==> A write to P2
#define CR (P2()->rfd)      // child  == B ==> B read from P2
#define CW (P1()->wfd)      // child  == B ==> B write to P1

// 创建2个管道
static void make_pipe(pipe_descripe* const pipe_arr){
    if(pipe(reinterpret_cast<int*>(get_pipe())) < 0){
        perror("pipe");
        exit(-1);
    }

    if(pipe(reinterpret_cast<int*>(get_pipe(true))) < 0){
        perror("pipe");
        exit(-1);
    }

    // 4个文件描述符设置为非阻塞的
    fcntl(PR, F_SETFL, fcntl(PR, F_GETFL) | O_NONBLOCK);
    fcntl(PW, F_SETFL, fcntl(PW, F_GETFL) | O_NONBLOCK);
    fcntl(CR, F_SETFL, fcntl(CR, F_GETFL) | O_NONBLOCK);
    fcntl(CW, F_SETFL, fcntl(CW, F_GETFL) | O_NONBLOCK);

    // PS: 注意实际开发中, 该函数应该是一个模块, 在开始前设置文件描述符, 结束后为还原,
    //     这里偷懒没有还原
}



static void poll(bool child = false){
    tuple<int,int> fds;
    get<0>(fds) = child?CR : PR;
    get<1>(fds) = child?CW : PW;

    // get<0> 表示 read
    // get<1> 表示 write

    // 必须有一方先发起通信(因为没有服务器器来中转), 这里选择父进程
    OPER_STA state = child ? OPER_STA::read : OPER_STA::write;
    while(1){
        switch(state){
            case OPER_STA::read:{
                auto rn = read(get<0>(fds), BUF, BUF_SIZE);
                if(rn < 0){
                    if(errno == EAGAIN){ // 只是退出swich, 还是会循环来这里
                       // sleep(1);
                        break;
                    }
                    state = OPER_STA::ex;
                }
                
                if(rn == 0){
                    //管道有结束状态, 要继续读取
                    //state = OPER_STA::over;
                    break;
                }
                state = OPER_STA::write;
            }break;

            case OPER_STA::write:{
                if(strlen(reinterpret_cast<char*>(BUF))){
                    // 这里是模拟, 先将收到的信息回显到屏幕, 然后从标准输入键入消息, 发送出去
                    cout << (child ? "child" : "parent") << " receive:" << BUF << "\nreplay:" << flush;
                }else{
                    cout << "send msg to " << (child ? "parent" : "child") << ":" << flush;
                }
                memset(BUF, 0, BUF_SIZE);
                string msg;
                getline(cin, msg);

                ssize_t pos = 0;
                string::size_type wn = 0;
                while(1){
                    wn = write(get<1>(fds), msg.c_str() + pos, msg.length());
                    if(wn < 0){
                        if(errno == EAGAIN)
                            continue;

                        // 出错, 结束
                        state = OPER_STA::ex;
                        break;
                    }

                    // 记录这一次写入的数据量
                    pos += wn;  

                    // 表示回复的内容已经全部写完, 继续监听read
                    if(pos == msg.length()){
                        pos = 0;
                        state = OPER_STA::read;
                        break;
                    }
                }
            }break;

            case OPER_STA::over:{
                cout << "over\n" << flush;
                exit(0);
            }break;

            case OPER_STA::ex:{
                child?perror("child err"):perror("parent err");
                exit(-1);
            }break;

            default:
                cerr << "no oper type\n";
                exit(-1);
                break;
        }
    }
}


int main(int args, char** argv){

    make_pipe(PIPES);

    auto child = fork();
    if(child < 0){ perror("fork"); exit(-1);}


#if 0
    fork前有2个管道
    PIPES[0] 表示P1
    PIPES[1] 表示P2

    fork后就有了4个管道
    子进程也是一模一样的.
    但开发中, 一般会在父子进程中关闭相关的描述符
#endif

    if(!child){ // chhild中
        // 子进程关闭 P1的读, 因为它只写P1
        close(P1()->rfd);
        // 子进程关闭 P2的写, 因为它只读P2
        close(P2()->wfd);

        poll(true);

        return 0;
    }

    // 父进程关闭 P1的写, 因为它只从P1读
    close(P1()->wfd);
    // 父进程关闭 P2的读, 因为它只写P2
    close(P2()->rfd);

    poll();

    return 0;
}
```

<br/>

> 上述程序很简单, 模拟实现2方对话. 因为父子进程应该由read操作来驱动write, 所以开始后必须有1方先发送个消息. 当有1方收到消息后, 另一方会从read状态取到消息, 然后回显到屏幕, 之后从键盘输入回复的内容, 以此模式来进行通信. 下面是测试结果:

---

<img src="./assets/13_05.gif"/>

---

<br/>

> 该版本存在问题: 虽然在逻辑上区分开了用户A和B(`程序中使用了父子进程`), 但不符合应用场景. 实际应该是不同的2端通过中间方来间接通信. 中间方类似于一个服务进程. 如下图
>


```mermaid
flowchart LR
    A ---->|a wto PSA =>= s rfr PSA | S ---->|s wto P2 =>= b rfr P2| B
    B ---->|s rfr PSB =<= b wto PSB| S ---->|a rfr P1 =<= s wto P1| A
```

<br/>

> 图中的`S`表示`service`. A和B的通信必须由S来中转. 所以多了2条管道PSA和PSB. 
>
> 大致逻辑是: S通过 PSX 管道接收来自A和B的消息, 同时通过 PX 管道又将消息转发给对方. 图中涉及到了多条管道, 看起来比较复杂冗余, 原因是将管道视作了单工, 单纯的2方通信时, 必须有2条管道.
>
> 下面的代码使用了命名管道, 并在逻辑架构上将角色区分开了. 有所谓的S端(服务器)和用户端(U). 首先看一下架构 

<br/>

```txt
    S端:
        1. 启动就打开 sa.pipe和sb.pipe, 扫描连接(connect --> read)
        2. 提取消息(read的回调)类型:
            > login:对方请求登录, 然后打开px管道, 回复对方登录成功
            > quit: 退出, 这里是服务器直接结束
            > r: 表示消息转发, 切换管道(从回复登录成功切换到转发对方用户), 同时消息写入转发管道

    U端:
        1. 启动打开 px.pipe, sx.pipe
        2. 子线程中从标准输入中获取内容写入到 sx.pipe
            > 同时将内容记录到文件 xx.db
        3. 主线程扫描px.pipe
            > login success: 登录成功的回调, 将其写入文件, 再进入到read
            > 其他消息, 写入到文件


    类:
        service
        
        user

        msg(辅助类)
            统一了状态, 对于S来说可能用到较多的状态, 对于user来说, 可能只用到了 read, login等少数的状态
```

<br/>

> 结构树

```shell
├── server.cpp
├── msg.cpp
├── msg.h
└── msg_protocol.h


├── main
├── main.cpp
├── msg.cpp
├── msg.h
└── msg_protocol.h



## 管道文件 sa.pipe sb.pipe p1.pipe p2.pipe
```

<br/>


```cpp
// 资源头文件msg_protocol.h
#ifndef __MSG_PROTOCOL_H__
#define __MSG_PROTOCOL_H__

constexpr auto CONNECT_PIPE_SA  = "./sa.pipe";    // s read from sa <==> a write to sa
constexpr auto CONNECT_PIPE_SB  = "./sb.pipe";    // s read from sb <==> b write to sb
constexpr auto CONNECT_PIPE_P1  = "./p1.pipe";    // s write to P1  <==> a read from P1
constexpr auto CONNECT_PIPE_P2  = "./p2.pipe";    // s write to P2  <==> b read from P2


#ifdef SERVER       // server进程使用
#include <map>
#include <tuple>
#include <cstdio>
static inline std::map<decltype(CONNECT_PIPE_P1), std::tuple<FILE*, int>>& _init(void){
    static std::remove_const_t<std::remove_reference_t<decltype(_init())>> rmap;
    return rmap;
}

#define MAP (_init())
#define SA (std::get<0>(MAP[CONNECT_PIPE_SA]))
#define SB (std::get<0>(MAP[CONNECT_PIPE_SB]))
#define P1 (std::get<0>(MAP[CONNECT_PIPE_P1]))
#define P2 (std::get<0>(MAP[CONNECT_PIPE_P2]))
#endif


#endif /* __MSG_PROTOCOL_H__ */





// msg.h
#ifndef __MSG_H__
#define __MSG_H__

#include <cstdio>

#define NAME_SPACE_BEGIN(_name)  namespace _name {
#define NAME_SPACE_END(_name)    }


#define MSG_ALIGN \
    __attribute__((aligned(sizeof(void*))))


NAME_SPACE_BEGIN(lbmsg)


enum class iostatus{
    CONNECT,
    LOGIN,
    READ,
    WRITE,
    QUIT,
    EXCEPTION,
    TERM,
}MSG_ALIGN;

struct msg{
    static constexpr auto BUF_LEN          = 0x100;
    iostatus    status;
    FILE*       sfile;
    FILE*       dfile;
    union{
        char        content[BUF_LEN];
        char        err[];
    };

    // 服务器会调用该函数
    void connect(void (*)(lbmsg::msg&));

    // 注意后面的 回调(必须由调用方实现)
    void login(const char* = nullptr, void fun(lbmsg::msg&) = [](lbmsg::msg&self)->void{}) noexcept(false);
    void read(void (*)(lbmsg::msg& self, const char*));
    void write();

    static void write(msg& self, FILE*);

    void quit(void);
    void exception(void);
    void term(void);

    msg& self() const{return const_cast<msg&>(*this);}

}MSG_ALIGN;


NAME_SPACE_END(lbmsg)



#undef MSG_ALIGN

#endif /* __MSG_H__ */





/// msg.cpp
//
//  msg.cpp
//  unix
//
//  Created by lb on 2024/3/10.
//

#include "msg.h"

#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <iostream>



#define self self()


#ifdef DEBUG
    #define SLEEP(_n) sleep(_n)
#else
    #define SLEEP(_n)
#endif


void lbmsg::msg::quit(void){
    std::cerr << "quit\n";
    this->status = iostatus::TERM;
}

void lbmsg::msg::exception(void){
    perror(this->err);
    this->status = iostatus::TERM;
}

void lbmsg::msg::term(void){
    exit(-1);
}


void lbmsg::msg::connect(void (*fun)(lbmsg::msg&)){
    fun(self);
}

void lbmsg::msg::login(const char* relpay, void (*fun)(lbmsg::msg&)) noexcept(false){
    if(!fun)
        throw "must have a callback";
    if(relpay){
        snprintf(self.content, strlen(relpay) + 1, "%s", relpay);
    }
    fun(self);
}

void lbmsg::msg::read(void (*fun)(msg&, const char*)){
    void* res = nullptr;
    res = fgets(self.content, BUF_LEN, self.sfile);
    if(res)
        return fun(self, self.content);

    if(ferror(self.sfile)){
        if(EAGAIN == errno){
            SLEEP(1);
            clearerr(self.sfile);
            return;
        }
        memcpy(self.err, "read\0", 5);
        self.status = iostatus::EXCEPTION;
        return;
    }

    if(feof(self.sfile)){
        SLEEP(1);
        clearerr(self.sfile);
        return;
    }
}

void lbmsg::msg::write(){
    self.write(self, self.dfile);
}


void lbmsg::msg::write(msg& call, FILE * file){
    int len = static_cast<int>(strnlen(call.content, BUF_LEN));
    int pos = 0;
    int wn = 0;
    while(1){
        wn = fputs(call.content + pos, file);
        if(wn){
            pos += wn;
            if(pos == len){
                memset(call.content, 0, BUF_LEN);
                fflush(file);
                call.status = iostatus::READ;   // 内容发送完毕, 继续读
                break;
            }
            continue;
        }
        if(ferror(call.dfile)){
            if(EAGAIN == errno){
                SLEEP(1);
                clearerr(call.dfile);
                continue;;
            }
            memcpy(call.err, "write\0", 6);
            call.status = iostatus::EXCEPTION;
            break;
        }
    }
}







// U端
#include<unistd.h>
#include<fcntl.h>

#include<iostream>
#include <fstream>
#include<string>
#include<functional>
#include<thread>

#include<cstdio>

#include"msg_protocol.h"
#include"msg.h"

static std::ofstream dbfile;

int main(int args, char** argv){
    if(args != 2){
        std::cerr << "usage ./main <user-type>(user_a or user_b)\n";
        exit(-1);
    }

    std::cout << "tid:" << getpid() << std::endl;
    chdir("/Users/liubo/Desktop/work/study/code");

    std::string cmd_user(argv[1]);
    std::transform(cmd_user.begin(), cmd_user.end(),cmd_user.begin(), ::toupper);
    bool is_a = cmd_user.compare("USER_A") == 0; 

    // 当前用户读PX
    auto rfd = open(is_a ? CONNECT_PIPE_P1 : CONNECT_PIPE_P2, O_RDONLY | O_NONBLOCK);
    if(rfd < 0){
        perror("open");
        exit(-1);
    }
    auto rf = fdopen(rfd, "r");
    if(nullptr == rf){
        perror("fdopen r");
        exit(-1);
    }

    // 当前用户写 SX
    auto wfd = open(is_a ? CONNECT_PIPE_SA : CONNECT_PIPE_SB, O_WRONLY | O_NONBLOCK);
    // 服务器没有打开 SX 管道(以非阻塞写打开管道时, 若没有读端, 会报错)
    if(wfd < 0){
        perror("open");
        exit(-1);
    }
    

    auto wf = fdopen(wfd, "w");
    if(!wf){
        perror("fdopen w");
        exit(-1);
    }


    // 负责将读取到的数据 和 将发送给对方的数据 写入到文件
    dbfile.open(is_a ? "a.db" : "b.db", std::ios::ios_base::out | std::ios::ios_base::trunc);
    if(!dbfile){
        perror("open db fail");
        exit(-1);
    }


    lbmsg::msg sock{
        .status = lbmsg::iostatus::READ,
        .sfile = rf,
        .dfile = wf,
        .content = {0}
    };


    std::thread([](const lbmsg::msg* Self){
        auto& self = *Self;
        char buf[lbmsg::msg::BUF_LEN] = {0};
        while(1){
            std::cin.getline(buf, sizeof(buf));
            dbfile << buf << std::endl;
            fputs(buf, self.dfile);
            fflush(self.dfile);
            memset(buf, 0, sizeof(buf));
        }
    }, &sock).detach();


    while(1){
        switch (sock.status){

            case lbmsg::iostatus::CONNECT:
            case lbmsg::iostatus::WRITE:
            break;

            case lbmsg::iostatus::LOGIN:{
                dbfile << "login success\n" << std::flush;
                sock.status = lbmsg::iostatus::READ;
            }break;

            case lbmsg::iostatus::READ:{
                sock.read([](lbmsg::msg& self, const char* content){
                    std::string str(content);
                    std::transform(str.begin(), str.end(), str.begin(), ::toupper);
                    if(str == "LOGIN SUC"){
                        self.status = lbmsg::iostatus::LOGIN;        // 服务器告诉当前用户登录成功了, 先调整到login, 打印一下日志
                        return;
                    }
                    dbfile << self.content << std::endl;
                });
            }break;

            case lbmsg::iostatus::QUIT:{
                sock.quit();
            }break;

            case lbmsg::iostatus::EXCEPTION:{
                sock.exception();
            }break;

            case lbmsg::iostatus::TERM:{
                sock.term();
            }break;

            default:
                std::cerr << "unrecognized status\n";
                exit(-1);
                break;
        };
    }
    return 0;
}







// S端
#include<unistd.h>
#include<fcntl.h>
#include<iostream>
#include<string>
#include<vector>
#include <functional>
#include <algorithm>

#define SERVER
#include "./msg_protocol.h"
#include "./msg.h"



static void init(void){
    // 最开始只打开 SA 和 SB(P1和P2在客户连上后再打开)
    for(auto& item : {CONNECT_PIPE_SA, CONNECT_PIPE_SB}){
        // 打开文件时以非阻塞打开, 不然会阻塞(后面要映射到file)
        auto connect_fd = open(item, O_RDONLY | O_NONBLOCK);
        if(connect_fd < 0){
            perror("open");
            exit(-1);
        }

        auto file = fdopen(connect_fd, "r");
        if(nullptr == file){
            perror("fdopen");
            exit(-1);
        }
        MAP[item] = std::make_tuple(file, connect_fd);
    }
}

static inline void connect_cbk(lbmsg::msg& self);
static inline void login_cbk(lbmsg::msg& self);
static void read_cbk(lbmsg::msg& self, const char* content);






static void poll(void){
    std::vector<lbmsg::msg> socks{
        {lbmsg::iostatus::CONNECT, SA, nullptr, ""},
        {lbmsg::iostatus::CONNECT, SB, nullptr, ""},
    };
    // 所有的操作当状态改变后, 要等待到下一次循环时才会执行
_begin:
    for(auto& sock : socks){
        switch (sock.status) {
                // 等待连接的状态, 要读取 sfile
            case lbmsg::iostatus::CONNECT:{
                sock.connect(connect_cbk);
            }break;

            case lbmsg::iostatus::LOGIN:{
                sock.login("login suc", login_cbk);
            }break;

            case lbmsg::iostatus::READ:{
                sock.read(read_cbk);
            }break;

            case lbmsg::iostatus::WRITE:{
                sock.write();
            }break;

            case lbmsg::iostatus::QUIT:{
                sock.quit();
            }break;

            case lbmsg::iostatus::EXCEPTION:{
                sock.exception();
            }break;

            case lbmsg::iostatus::TERM:{
                sock.term();
            }break;

            default:
                std::cerr << "unrecognized status\n";
                exit(-1);
                break;
        }
    }
goto _begin;

}





int main(int args, char** argv){
    std::cout << "tid:" << getpid() << std::endl;
    chdir("/Users/liubo/Desktop/work/study/code");

    init();

    poll();

    fclose(SA);
    fclose(SB);
    fclose(P1);
    fclose(P2);
}



static inline void connect_cbk(lbmsg::msg& self){
    self.status = lbmsg::iostatus::READ;
}

static inline void login_cbk(lbmsg::msg& self){
    // 服务器回复 发送方 登录成功(注意不能将消息发送到 另一方客户)
//    lbmsg::msg::write(self, self.sfile == SA ? P1 : P2);
    self.status = lbmsg::iostatus::WRITE;
}

static std::tuple<FILE*, int> open_pipe(lbmsg::msg& self,decltype(CONNECT_PIPE_P1) pipe, int mode = O_NONBLOCK | O_WRONLY){
    auto fd = open(pipe, O_NONBLOCK | O_WRONLY);
    if(fd < 0){
        memcpy(self.err, "open\0", 5);
        self.status = lbmsg::iostatus::EXCEPTION;
        return std::make_tuple(nullptr, -1);
    }

    auto file = fdopen(fd, "w");
    if(!file){
        memcpy(self.err, "open\0", 5);
        self.status = lbmsg::iostatus::EXCEPTION;
        return std::make_tuple(nullptr, -1);
    }

    return std::make_tuple(file,fd);
}


static void read_cbk(lbmsg::msg& self, const char* content){
    std::string str(self.content);
    std::transform(str.begin(), str.end(), str.begin(), ::toupper);



    if(str == "QUIT"){
        self.status = lbmsg::iostatus::TERM;
        return;
    }


    if(str.compare("LOGIN") == 0){
        // eg: A登录成功, 则S打开P1(回复A登录成功)
        auto pipe = self.sfile == SA ? CONNECT_PIPE_P1 : CONNECT_PIPE_P2;

        if(nullptr == get<0>(MAP[pipe])){
            MAP[pipe] = open_pipe(self, pipe);
        }
        
        // 暂时记录输出的目标管道
        self.dfile = get<0>(MAP[pipe]);
        memset(self.content, 0, lbmsg::msg::BUF_LEN);
        self.status = lbmsg::iostatus::LOGIN;
        return;
    }

#if __cplusplus >= 2020
    // 表示 用户XXX 想回复 用户NNN, 切换输出的目标管道
    str = content;
    if(str.starts_with("r:")){
        auto pipe = self.sfile == SA ? CONNECT_PIPE_P2 : CONNECT_PIPE_P1;

        if(get<0>(MAP[pipe]) == nullptr){
            MAP[pipe] = open_pipe(self, pipe);
            if(get<0>(MAP[pipe]) == nullptr){
                self.status = lbmsg::iostatus::EXCEPTION;
                return;
            }
        }
        self.dfile = get<0>(MAP[pipe]);
        str.erase(str.begin(), str.begin() + strlen("r:"));
        str = std::string("receive from") + (self.sfile == SA ? " a:" : " b:") + str;
        strncpy(self.content, str.c_str(), str.length());
        self.status = lbmsg::iostatus::WRITE;
        return;
    }
#endif
}
```

---


<img src="./assets/13_06.gif" />

---


<br/>


> 该程序只是简单实现了通信, 里面还有非常多的细节, 如实际场景中管道的替代者即为socket文件描述符; 消息格式的定义, 连接出错的处理, 断连重连, 日志记录等等. 该模型只处理了1组通信, 下面的案例是实现S管理多组通信, 事实上S作为服务器应该是多个用户的消息转发者 
































